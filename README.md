#  PROJECT ELTEX

## 1LAB
Проект представляет собой программу на языке C, которая работает с переводом двоичных чисел при помощи битовых операций.
## 2LAB
Проект представляет собой программу на языке C, которая трансформирует матрицу.
## 3LAB
Задания на указатели.
## 4LAB
Написать программу абонентский справочник. Список абонентов представляет собой статический массив (100 элементов) из структур.
## 5LAB
1. Переписать абонентский справочник с использованием функций.
2. Вам необходимо произвести анализ программы с помощью отладчика для выяснения длины массива для ввода пароля и адреса ветки условия проверки корректности ввода пароля, которая выполняется при условии совпадения паролей. Ввести пароль (строку символов)таким образом, чтобы перезаписать адрес возврата на выясненный адрес (есть символы которые нельзя ввести с клавиатуры, поэтому можно использовать перенаправление ввода(<) при
запуске программы).
## 6LAB
Переписать справочник абонентов (задание на структуры) со статического массива структур на двусвязный список структур.
## 7LAB
Реализовать программу калькулятор с функционалом над целыми числами: сложение, вычитание, умножение, деление. Использовать статическую библиотеку
## 8LAB
Переписать программу из задания на статические библиотеки так чтобы применялась динамическая библиотека. Т. е. чтобы весь функционал находился в динамической библиотеке
## 9LAB 
1) Написать программу, которая создает файл с именем output.txt, записывает в него строку “String from file”, затем считывает ее из файла с конца и выводит на экран.
2) Реализовать файловый менеджер на подобии mc (рисунок 1), с функционалом навигации по папкам и двумя панелями (переключение между панелями через Tab). Использовать для графики библиотеку
ncurses.
## 10LAB
1) Реализовать программу, которая порождает процесс. Родительский
процесс и дочерний выводят на экран свой pid, ppid. Затем родительский
ждет завершения дочернего и выводит его статус завершения.
2) Реализовать программу, которая порождает процесс1 и процесс2, ждет
завершения дочерних процессов. Процесс1 в свою очередь порождает
процесс3 и процесс4 и ждет их завершения. Процесс2 порождает
процесс5 и ждет его завершения. Все процессы выводят на экран свой
pid, ppid.
3) Реализовать аналог командного интерпретатора bash. При запуске
программы пользователю предлагается ввести имя программы и опции
запуска программы. Программа порождает процесс и в нем выполняет
введенную программу с заданными опциями, ждет завершения
дочернего процесса. Снова возвращается к вводу следующей
программы. Выход из интерпретатора по команде exit.
## 11LAB
1) Реализовать программу, погрузчик, покупатель, магазин.
## 12LAB
1) Реализовать программу, которая создает неименованный канал и
порождает процесс. Родительский процесс закрывает дескриптор для
чтения из канала и записывает в канал строку “Hi!”, затем ожидает
завершения дочернего процесса. Дочерний процесс закрывает
дескриптор для записи в канал, считывает строку из канала и выводит на
экран.
2) Реализовать 2 программы, первая сервер, вторая клиент. Сервер создает
именованный канал и открывает его только на запись, записывает строку
“Hi!” и завершается. Клиент открывает созданный канал сервером
только на чтение, считывает строку из канала и выводит на экран. Удает
канал.
3) Переписать командный интерпретатор из задания по процессам так,
чтобы он поддерживал конструкции вида:
$ ls -la | grep a
## 13LAB
Реализовать 2 программы, первая сервер, вторая клиент. Сервер создает
очередь сообщений и записывает сообщение виде строки “Hi!”, ждет
ответа от клиента и выводит на экран, удаляет очередь. Клиент
подключается к очереди считывает сообщение от сервера, выводит на
экран, отвечает серверу сообщением виде строки “Hello!”. Сделать это
как для POSIX, так и для SYSTEM V стандартов.
2) Написать 2 программы, первая сервер, вторая клиент. Сервер создает
очередь сообщений для реализации чата с общей комнатой (если
необходимо, то можно и больше очередей создать) и его задача
уведомлять клиентов о появлении новых участников, о новых
сообщениях. Клиент подключается к очереди, созданной сервером,
сообщает ему свое имя и получает в ответ все сообщения в комнате.
Далее может отправлять сообщения в общий чат. Получение служебных
сообщений от сервера (имена новых клиентов, сообщения от других
пользователей) и отправка сообщений в чат лучше реализовать в разных
потоках. Интерфейс клиента реализуем с помощью библиотеки ncurses.
## 14LAB
Реализовать 2 программы, первая сервер, вторая клиент. Сервер создает
сегмент разделяемой памяти (достаточный для хранения сообщений) и
записывает сообщение виде строки “Hi!”, ждет ответа от клиента и
выводит на экран, удаляет сегмент разделяемой памяти. Клиент
подключается к сегменту разделяемой памяти и считывает сообщение от
сервера, выводит на экран, отвечает серверу сообщением виде строки
“Hello!”. Сделать это как для POSIX, так и для SYSTEM V стандартов.
2) Написать 2 программы, первая сервер, вторая клиент. Сервер создает
сегмент разделяемой памяти для реализации чата с общей комнатой и
его задача уведомлять клиентов о появлении новых участников, о новых
сообщениях. Клиент подключается к сегменту разделяемой памяти,
созданному сервером, сообщает ему свое имя и получает в ответ все
сообщения в комнате. Далее может отправлять сообщения в общий чат.
Получение служебных сообщений от сервера (имена новых клиентов,
сообщения от других пользователей) и отправка сообщений в чат лучше
реализовать в разных потоках. Интерфейс клиента реализуем с помощью
библиотеки ncurses.
## 15LAB
1) Реализовать программу, которая переопределяет диспозицию сигнал
SIGUSR1 с помощью вызова sigaction(), после чего уходит в бесконечный
цикл ожидания. В функции диспозиции сигнала на экран выводится
сообщение о получении сигнала. Также необходимо реализовать вторую
программу, которая будет посылать первой программе сигнал SIGUSR1
через вызов kill(). Дополнительно научится посылать сигнал с помощью
утилиты kill.
2) Реализовать программу, которая будет блокировать сигнал SIGINT с
помощью вызова sigprocmask() и уходить в бесконечный цикл. Проверить
работу программы с помощью второй программы из задания 1 и утилиты
kill.
3) Написать программу, в которой реализуется event-loop с помощью
вызова sigwait(). При запуске программа блокирует сигнал SIGUSR1 и
переходит в бесконечный цикл ожидания сигнала, при получении сигнала
на экран выводится сообщение о получении сигнала и осуществляется
переход на следующую итерацию цикла. Проверить программу с помощью
второй программы из задания 1 и утилиты kill.
